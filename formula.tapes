set (alignsummands : 0.0).  // for now these have to be float
set (oldalignment : 0.0).
set (zerolenids : 1.0).

set (wrap_trace_ids : 1.0).

set (rounded_wires : 1.0).
set (join_wires : 1.0).
set (otimesdist : 0.5).
set (oplusdist : 0.25).
set (paddingdist : 0.5).
set (scalex : 0.7).


let A : sort.   let B : sort.   let C : sort.
let f : A -> C * C * C.

set (rounded_wires : 0.0).

let program : term = 

BEGIN_IMP [x : int]
while (r(x)) {
    if (r1(x)) then {
        x := (f(x) : int)
    } else {
        abort
    }
}
END_IMP.

check program.
draw program to "./result_examples/program".


let factorial : term = 

BEGIN_IMP [x : int, y : int]
y := x;
while (">1"(y)) {
    y := ("-1"(x) : int);
    x := ("\times"(x, y) : int)
}
END_IMP.

let factorial_twice : term = 

BEGIN_IMP [x : int, y : int]
y := x;
while (">1"(y)) {
    y := ("-1"(x) : int);
    x := ("\times"(x, y) : int)
};
y := x;
while (">1"(y)) {
    y := ("-1"(x) : int);
    x := ("\times"(x, y) : int)
}
END_IMP.

check factorial.
draw factorial to "./result_examples/factorial".

set (scalex : 0.9).
set (rounded_wires : 1.0).

let big_test_sum : term = (split(A*A);((split(A*A) ; ((gen(f, A * A, A) + gen(g, A * A, B * C)) ; (copy(A + (B*C))))) +
    (split(A*A) ; ((gen(f, A * A, A) + gen(g, A * A, B * C)) ;  (copy(A + (B*C))))))) + 
    (( split(A) ; ((gen(f, A, A) ; (id(A) + spawn(A) + spawn(A) + spawn(A))) + id(A)) ) ; ((id(A) + cut(A)) + cut(A) + cut(A) + id(A)) ; join(A)).

set (rounded_wires : 0.0).

let norm : tape = normalize_term
BEGIN_IMP [x : int, y : int]
y := x;
while (">1"(y)) {
    y := ("-1"(x) : int);
    x := ("\times"(x, y) : int)
}
END_IMP.

draw_normal_form big_test_sum to "./result_examples/big_test_matrix".

draw_trace_normal_form factorial_twice to "./result_examples/tracenf"