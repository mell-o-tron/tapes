set (alignsummands : 0.0).  // for now these have to be float
set (oldalignment : 0.0).
set (zerolenids : 0.0).

set (wrap_trace_ids : 1.0).

set (rounded_wires : 1.0).
set (join_wires : 1.0).
set (otimesdist : 0.5).
set (oplusdist : 0.25).
set (paddingdist : 0.5).
set (scalex : 0.7).


// let A : sort.   let B : sort.   let C : sort.
// let f : A -> C * C * C.

set (rounded_wires : 0.0).


let factorial : term = 

BEGIN_IMP [x : int, y : int]
y := x;
while (geq1(y)) {
    y := (dec(x) : int);
    x := (times(x, y) : int)
}
END_IMP.


check factorial.
draw factorial to "./result_examples/factorial".

set (scalex : 0.9).
set (rounded_wires : 1.0).

let big_test_sum : term = (split(A*A);((split(A*A) ; ((gen(f, A * A, A) + gen(g, A * A, B * C)) ; (copy(A + (B*C))))) +
    (split(A*A) ; ((gen(f, A * A, A) + gen(g, A * A, B * C)) ;  (copy(A + (B*C))))))) + 
    (( split(A) ; ((gen(f, A, A) ; (id(A) + spawn(A) + spawn(A) + spawn(A))) + id(A)) ) ; ((id(A) + cut(A)) + cut(A) + cut(A) + id(A)) ; join(A)).

set (rounded_wires : 0.0).


draw_normal_form big_test_sum to "./result_examples/big_test_matrix".


set (rounded_wires : 0.0).

axioms [
    plus(pos (), pos()) = pos(),
    minus(neg (), neg()) = neg()
].

let program : term = 
    BEGIN_IMP [x : sign]
    x := pos() : sign;
    while (not(eq(x, zero() : sign))) {
        x := plus(x, pos() : sign) : sign
    }
    END_IMP.

let program2 : term = 
    
    BEGIN_IMP [x : sign, y:sign]
    x := pos() : sign;
    y := pos() : sign;
    while (not(eq(x, zero() : sign))) {
        x := plus(x, pos() : sign) : sign;
        x := minus(x, pos() : sign) : sign
    }
    END_IMP.

// check_inclusion (program, program) with invariant 
//     BEGIN_TEST [x : sign]
//     eq(x, pos():sign)
//     END_TEST

draw_cospan ((s*(a, b)) ; gen(f, b * a, c); gen(g, c, d))  to "./result_examples/test_cospan"